// Code generated by protoc-gen-go.
// source: session.proto
// DO NOT EDIT!

package protocol

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Equiment int32

const (
	Equiment_PC      Equiment = 1
	Equiment_WEB     Equiment = 2
	Equiment_ANDROID Equiment = 3
	Equiment_IOS     Equiment = 4
)

var Equiment_name = map[int32]string{
	1: "PC",
	2: "WEB",
	3: "ANDROID",
	4: "IOS",
}
var Equiment_value = map[string]int32{
	"PC":      1,
	"WEB":     2,
	"ANDROID": 3,
	"IOS":     4,
}

func (x Equiment) Enum() *Equiment {
	p := new(Equiment)
	*p = x
	return p
}
func (x Equiment) String() string {
	return proto.EnumName(Equiment_name, int32(x))
}
func (x *Equiment) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Equiment_value, data, "Equiment")
	if err != nil {
		return err
	}
	*x = Equiment(value)
	return nil
}
func (Equiment) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type Status int32

const (
	Status_ONLINE  Status = 1
	Status_OFFLINE Status = 2
)

var Status_name = map[int32]string{
	1: "ONLINE",
	2: "OFFLINE",
}
var Status_value = map[string]int32{
	"ONLINE":  1,
	"OFFLINE": 2,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type LoginReq struct {
	Name             *string   `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Password         *string   `protobuf:"bytes,2,req,name=password" json:"password,omitempty"`
	Equiment         *Equiment `protobuf:"varint,3,req,name=equiment,enum=protocol.Equiment" json:"equiment,omitempty"`
	Status           *Status   `protobuf:"varint,4,opt,name=status,enum=protocol.Status,def=1" json:"status,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *LoginReq) Reset()                    { *m = LoginReq{} }
func (m *LoginReq) String() string            { return proto.CompactTextString(m) }
func (*LoginReq) ProtoMessage()               {}
func (*LoginReq) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

const Default_LoginReq_Status Status = Status_ONLINE

func (m *LoginReq) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *LoginReq) GetPassword() string {
	if m != nil && m.Password != nil {
		return *m.Password
	}
	return ""
}

func (m *LoginReq) GetEquiment() Equiment {
	if m != nil && m.Equiment != nil {
		return *m.Equiment
	}
	return Equiment_PC
}

func (m *LoginReq) GetStatus() Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_LoginReq_Status
}

type LoginRsp struct {
	Code             *int32  `protobuf:"varint,1,req,name=code,def=0" json:"code,omitempty"`
	Token            *string `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	Timeout          *int64  `protobuf:"varint,3,opt,name=timeout" json:"timeout,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *LoginRsp) Reset()                    { *m = LoginRsp{} }
func (m *LoginRsp) String() string            { return proto.CompactTextString(m) }
func (*LoginRsp) ProtoMessage()               {}
func (*LoginRsp) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

const Default_LoginRsp_Code int32 = 0

func (m *LoginRsp) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return Default_LoginRsp_Code
}

func (m *LoginRsp) GetToken() string {
	if m != nil && m.Token != nil {
		return *m.Token
	}
	return ""
}

func (m *LoginRsp) GetTimeout() int64 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

// backend -> client  when client received this message, the session is closed by backend, client should be disconnect the connection
type OfflineNotify struct {
	Code             *int32 `protobuf:"varint,1,req,name=code" json:"code,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *OfflineNotify) Reset()                    { *m = OfflineNotify{} }
func (m *OfflineNotify) String() string            { return proto.CompactTextString(m) }
func (*OfflineNotify) ProtoMessage()               {}
func (*OfflineNotify) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *OfflineNotify) GetCode() int32 {
	if m != nil && m.Code != nil {
		return *m.Code
	}
	return 0
}

type StatusNotify struct {
	UserId           *int32    `protobuf:"varint,1,req,name=userId" json:"userId,omitempty"`
	Equiment         *Equiment `protobuf:"varint,2,req,name=equiment,enum=protocol.Equiment" json:"equiment,omitempty"`
	Status           *Status   `protobuf:"varint,3,req,name=status,enum=protocol.Status" json:"status,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *StatusNotify) Reset()                    { *m = StatusNotify{} }
func (m *StatusNotify) String() string            { return proto.CompactTextString(m) }
func (*StatusNotify) ProtoMessage()               {}
func (*StatusNotify) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *StatusNotify) GetUserId() int32 {
	if m != nil && m.UserId != nil {
		return *m.UserId
	}
	return 0
}

func (m *StatusNotify) GetEquiment() Equiment {
	if m != nil && m.Equiment != nil {
		return *m.Equiment
	}
	return Equiment_PC
}

func (m *StatusNotify) GetStatus() Status {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Status_ONLINE
}

func init() {
	proto.RegisterType((*LoginReq)(nil), "protocol.LoginReq")
	proto.RegisterType((*LoginRsp)(nil), "protocol.LoginRsp")
	proto.RegisterType((*OfflineNotify)(nil), "protocol.OfflineNotify")
	proto.RegisterType((*StatusNotify)(nil), "protocol.StatusNotify")
	proto.RegisterEnum("protocol.Equiment", Equiment_name, Equiment_value)
	proto.RegisterEnum("protocol.Status", Status_name, Status_value)
}

var fileDescriptor1 = []byte{
	// 295 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x90, 0xcf, 0x6b, 0xbb, 0x30,
	0x18, 0xc6, 0x49, 0xb4, 0xd6, 0xef, 0xfb, 0xad, 0x6d, 0xc8, 0xc9, 0xcb, 0xc0, 0xc9, 0x0e, 0xd2,
	0x83, 0x6c, 0x3b, 0x76, 0xa7, 0x6d, 0xb5, 0x20, 0x14, 0x1d, 0xed, 0x61, 0x67, 0xa9, 0x71, 0xc8,
	0xda, 0xc4, 0x9a, 0xc8, 0xd8, 0xfe, 0xfa, 0xc5, 0x1f, 0x6d, 0x19, 0x63, 0xa7, 0x90, 0xe7, 0x7d,
	0xde, 0xe7, 0x93, 0x27, 0xe0, 0x48, 0x26, 0x65, 0x29, 0x78, 0x58, 0xd5, 0x42, 0x09, 0x6a, 0x77,
	0xc7, 0x4e, 0xec, 0xfd, 0x2f, 0xb0, 0xd7, 0xe2, 0xad, 0xe4, 0x1b, 0x76, 0xa4, 0x13, 0x30, 0x79,
	0x76, 0x60, 0x2e, 0xf2, 0x70, 0xf0, 0x8f, 0x12, 0xb0, 0xab, 0x4c, 0xca, 0x0f, 0x51, 0xe7, 0x2e,
	0xee, 0x94, 0x1b, 0xb0, 0xd9, 0xb1, 0x29, 0x0f, 0x8c, 0x2b, 0xd7, 0xd0, 0xca, 0xf4, 0x9e, 0x86,
	0xa7, 0xa0, 0x30, 0x1a, 0x26, 0x34, 0x00, 0x4b, 0xaa, 0x4c, 0x35, 0xd2, 0x35, 0x3d, 0xa4, 0x3d,
	0xe4, 0xe2, 0xd9, 0x76, 0xfa, 0xc2, 0x4a, 0x93, 0x75, 0x9c, 0x44, 0xfe, 0xc3, 0x89, 0x2d, 0x2b,
	0x3a, 0x03, 0x73, 0x27, 0xf2, 0x9e, 0x3d, 0x5a, 0xa0, 0x5b, 0xea, 0xc0, 0x48, 0x89, 0x77, 0xc6,
	0x35, 0x1b, 0x69, 0xf6, 0x0c, 0xc6, 0x4a, 0xe7, 0x8b, 0xa6, 0x45, 0xa3, 0xc0, 0xf0, 0xaf, 0xc0,
	0x49, 0x8b, 0x62, 0x5f, 0x72, 0x96, 0x08, 0x55, 0x16, 0x9f, 0xed, 0xeb, 0x2f, 0x09, 0x7e, 0x01,
	0x93, 0x9e, 0x36, 0x4c, 0xa7, 0x60, 0x35, 0x92, 0xd5, 0x71, 0xde, 0xcf, 0x7f, 0x74, 0xc1, 0x7f,
	0x76, 0xf1, 0xce, 0x5d, 0xfa, 0xbe, 0xbf, 0xba, 0xcc, 0xef, 0xc0, 0x3e, 0xbb, 0x2d, 0xc0, 0x2f,
	0xcf, 0x04, 0xd1, 0x31, 0x18, 0xaf, 0xd1, 0x13, 0xc1, 0xf4, 0x3f, 0x8c, 0x1f, 0x93, 0xe5, 0x26,
	0x8d, 0x97, 0xc4, 0x68, 0xd5, 0x38, 0xdd, 0x12, 0x73, 0x7e, 0x0d, 0x56, 0xbf, 0x4c, 0x01, 0x86,
	0xaf, 0xd0, 0x4b, 0xda, 0x9b, 0xae, 0x56, 0xdd, 0x05, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x45,
	0x4e, 0x2c, 0x79, 0xaf, 0x01, 0x00, 0x00,
}
